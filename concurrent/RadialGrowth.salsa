module concurrent; 

import java.io.*;
import java.util.*;
import java.lang.*;

// Kevin De Leon
// Rasika Ekhalikar

behavior RadialGrowth{

	// creates a linked list of nodes
 	Node[] nodes = new Node[8];
 	int counter = 0;
 	int totalTime =0;
 	int done =0;

 	// constructor-kicks off the program
 	RadialGrowth(String[] args){
 		act(args);
 	}

	void act(String[] args){

		// ensures we have the correct number of arguments
		if(args.length != 1){
			standardError<-println("[error] incorrect amount of arguments. Expecting 1, received " + args.length);
			return;
		}

		String filename = args[0];	// stores the filename

		try{
			// opens the output file to clear it and closes it
			BufferedWriter out = new BufferedWriter(new FileWriter("output.txt",false));	
			out.close();																	
			// opens the input file and reads line by line
			BufferedReader reader = new BufferedReader(new FileReader(args[0])); 
			
			// reads line by line
			String line;
			
			while((line = reader.readLine()) != null){ 	
				// creates a new node
				Node newNode = new Node(line);

				// adds the node to the linked list
				nodes[counter] = newNode;
				counter++;
			}

			// closes the input file
			reader.close();

		// catches an exception when opening the file
		}catch(IOException ioe){
			standardError<-println("[error] Can't open the file "+filename+"\n"+ioe);
			return;
		}

		// sets a nodes left and right nodes
		for(int i=0;i<counter-1;i++){
			nodes[i+1]<-setLeft(nodes[i]);
			nodes[i]<-setRight(nodes[i+1]);
		}

		// sets the first node's left equal to the last node
		nodes[0]<-setLeft(nodes[counter-1]);

		// sets the last node right equal to the first node
		nodes[counter-1]<-setRight(nodes[0]);
		
		// tells nodes the size of the list
		for(int i=0;i<counter;i++){
			nodes[i]<-setSize(counter);
		}

		// starts the first election
		beginElection(0,0);
		// leaderTime(int time, int revolts,int pastLeaders, int localTime)
		// join {
		// 	nodes[0]<-geCurrentLeader();
		// 	nodes[1]<-geCurrentLeader();
		// 	nodes[2]<-geCurrentLeader();
		// 	nodes[3]<-geCurrentLeader();
		// 	nodes[4]<-geCurrentLeader();
		// }@printResults(token);
	}

	void printResults(Object results[]){
		for (int i=0;i<5;i++){
			standardOutput<-println(i +" "+results[i]);
		}
	}

	int ha(Object results[]){
		int next = -1;
		for (int i=0;i<5;i++){
			
			if (next == -1 && results[i]!=-1){
				next = (Integer)results[i];
			}
			if (next != -1 && results[i] == next){
				next = (Integer) results[i];
			}
			if (next != -1 && results[i] == next){
				next = -5;
			}
		}
		standardOutput<-print(next);
		standardOutput<-println("Hello");

		return next;
	}

	int ret(int r){
		return r;
	}

	int figureOutLeader(){
		standardOutput<-println("hello");
		join{
			for (int i=0;i<5;i++){
				nodes[i]<-getWant();
				// standardOutput<-println(a);
			}
			// standardOutput<-println("hi");
		}@ha(token);

		for (int i=0;i<5;i++){
				token a = nodes[i]<-getWant();
				//standardOutput<-println(a);
		}
		//return (( Integer )results [ 0 ] ) . intValue ();
		//return ret(results[0]);
		return -1;

	}
	void beginElection(int time, int pastLeaders){
		Node temp = nodes[0];

		token t2 = temp<-getNumLeaders();
		//ha(t2);
		// standardOutput<-println(t2);
		if (pastLeaders == 5){
		 	return;
		}

		join{
			for(int a=0; a < counter;a++){
				(nodes[a])<-startElection(time,pastLeaders);
			}
		}@ha(token)@
		(nodes[0])<-setCurr();
		token t1 = temp<-getTime();
		(nodes[0])<-leaderTime(t1, 0,++pastLeaders, 0); //need a way to pass token to nodes[0]
		t1 = temp<-getTime();
		standardOutput<-println(t1);
		beginElection(t1, pastLeaders);
	}

}
