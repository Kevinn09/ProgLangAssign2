module concurrent;

import java.io.*;
import java.util.*;

behavior Node{

  int id;                   // node ID
  int priority;             // node priority
  int tolerance;            // how long they can tolerate someone else being a leader
  int ttl;                  // time to live (or hop limit) of the node's message
  int size;                 // how many nodes there are
  int time1;                // time of last deposition
  int numPastLeaders;       //number of past leaders
  int wantLeader;

  boolean canBeLeader;      // if the node can be a leader
  boolean tempCanBeLeader;  // if there already is a leader
  boolean hasBeenLeader;    // if the node has been a leader
  boolean currentLeader;    // if the node is currently a leader
  boolean hasRevolted;      // if the node has revolted

  Node left;                // node to the left of the current node
  Node right;               // node to the right of the current node

  // node constructor that takes in a file and parses the information
  // from the line to fill in its variables
  Node(String fileLine){
    String[] inputs = fileLine.split("\t"); //parses the line

    // initilization of all the variables  
    id = Integer.parseInt(inputs[0]);       
    priority = Integer.parseInt(inputs[3]);
    tolerance = Integer.parseInt(inputs[4]);
    ttl = 1;
    size = 0;
    time1 = 0;
    numPastLeaders = 0;
    canBeLeader = true;
    tempCanBeLeader = true;
    hasBeenLeader = false;
    currentLeader = false;
    hasRevolted = false;
    wantLeader = -1;
  }

  void update(int newTime, int counter, int newLeaders){
    if(counter < size){
      time1 = newTime;
      numPastLeaders = newLeaders;
      counter++; // keeps track of how many nodes we have reset
      left<-update(newTime,counter,newLeaders);
    }
    return;
  }

  int getTime(){
    return time1;
  }
  boolean geCurrentLeader(){
    return currentLeader;
  }

  int getWant(){
    return wantLeader;
  }
  int getNumLeaders(){
    return numPastLeaders;
  }

  // input: Node to the left of the current node
  // Sets left node to the current node
  void setLeft(Node toLeft){
    left = toLeft;
    return;
  }

  // input: Node to the right of the current node
  // Sets right node to the current node
  void setRight(Node toRight){
    right=toRight;
    return;
  }

  // input: size
  // sets the size
  void setSize(int s){
    size = s;
    return;
  }

  // input: message to be printed
  // opens the file and prints a status message to output.txt
  void printStatusMessage(String mess){
    try{
      PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter("output.txt", true)));
      out.println(mess);  // adds the message
      out.close();        // closes the file

    // error handling
    }catch(IOException ioe){
      standardError<-println("[error] Can't open the file for writing.");
    }
  }


  // input: place holder that will keep track of how many nodes we have reset
  // resets hasRevolted and ttl of all nodes when we need to find a new leader
  void reset(int counter){
    if (counter < size){
      hasRevolted = false;
      ttl = 1;
      counter++; // keeps track of how many nodes we have reset
      left<-reset(counter);
    }
    return;
  }
  void leaderChosen(boolean chosen,int counter){
    if(counter < size){
      if(chosen == true){ // leader was chosen
        // no one can be a leader anymore, someone already is
        tempCanBeLeader = false;
      }else{
        // anyone can be a leader, no one is anymore
        tempCanBeLeader = true;
      }
      counter++;
      left<-leaderChosen(chosen,counter);
    }
    return;
  }

  void setCurr(){
    currentLeader=true;
  }

  int receiveMessage(int senderId, int senderPriority, boolean senderLeaderStatus, int tTL, int pastLeaders,int time,int localTime, boolean direction){
    // if the sender's ID == the current node's id && if current node can be a leader
    if( senderId == id && canBeLeader && currentLeader==false && senderLeaderStatus ==true ){
      wantLeader = 10;
      return id;
    // if it is a node that is not the message sender
    }else{
      tTL--; 
      if(priority >= senderPriority && canBeLeader){
        senderLeaderStatus = false;
      }else if(priority == senderPriority && canBeLeader){
        if(id > senderId){
          senderLeaderStatus = false;
        }
      }

      // if tTL is 0, let the original sender know if it can be a leader
      if(tTL == 0 ){
        if(direction){
          left<-replyMessage(id,senderId,senderLeaderStatus,pastLeaders,time,localTime,direction);
        }else{
          right<-replyMessage(id,senderId,senderLeaderStatus,pastLeaders,time,localTime,direction);
        }
      }else if(tempCanBeLeader){
        if(direction){
          right<-receiveMessage(senderId,senderPriority,senderLeaderStatus,tTL,pastLeaders,time,localTime,direction);          
        }else{
          left<-receiveMessage(senderId,senderPriority,senderLeaderStatus,tTL,pastLeaders,time,localTime,direction);
        }
      }
    }
    //standardOutput<-println(t1);
    return -1;
  }
  void leaderTime(int time, int revolts,int pastLeaders, int localTime){

    // checks node's tolerance to time leader has been a leader
    if(localTime >= tolerance && currentLeader == false && hasRevolted==false){
      hasRevolted= true;  //sets the revolt flag
      revolts++;          //increases the number of revolts

      printStatusMessage("ID=" + Integer.toString(id) + " revolted at t="+Integer.toString(time));
      
      time++;
      localTime++;
      left<-leaderTime(time, revolts, pastLeaders,localTime);

    // if enough nodes have revolted, then it is time for a new leader
    }else if (revolts >= ((size + 1)/2) && currentLeader){
      currentLeader=false;
      pastLeaders++;
      localTime++;
      printStatusMessage("ID=" + Integer.toString(id) + " was deposed at t="+Integer.toString(time));
      printStatusMessage("Number of leaders" + pastLeaders);
      time++;
      left<-update(time,0,pastLeaders)@
      left<-leaderChosen(false,0);

      // return -1;
      // left<-startElection(time,pastLeaders);

    // otherwise, keep going
    }else{
      localTime++;
      time++;
      left<-leaderTime(time,revolts,pastLeaders,localTime);
    }
    // return -1;
  } 

  int replyMessage(int newId, int senderId, boolean senderLeaderStatus, int pastLeaders,int time,int localTime, boolean direction){
    // original sender recieved the reply
    if(id == senderId){
      if(senderLeaderStatus && tempCanBeLeader){
        ttl *= 2;
        right<-receiveMessage(id,priority,canBeLeader,ttl,pastLeaders,time,localTime,direction);
        left<-receiveMessage(id,priority,canBeLeader,ttl,pastLeaders,time,localTime,direction);    
      // if it cannot be a leader then move on to the next node
      }else{
        return -1;
        // left<-startElection(time,pastLeaders);
      }

    // if it is not the original sender, keep sending till it is
    }else{
      if(direction){
        left<-replyMessage(newId,senderId,senderLeaderStatus,pastLeaders,time,localTime,direction);
      }else{
        right<-replyMessage(newId,senderId,senderLeaderStatus,pastLeaders,time,localTime,direction);
      }
    }
    return -1;
  }

  int findLead(Object results[]){
    standardOutput<-print(results[0]);
    standardOutput<-println(results[1]);
    if (wantLeader  != -1 ){
      canBeLeader = false;
      hasBeenLeader = true;
      standardOutput<-println("hii");
      return id;
    }
    return -1;

  }

  int returnTok(Object tok){
    return  (( Integer ) tok) . intValue ( ) ;
  }


  // this is to kick off finding a new leader
  int startElection(int timestamp, int pastLeaders){
    if(tempCanBeLeader){
      join{
        right<-receiveMessage(id,priority,canBeLeader,ttl,pastLeaders,timestamp,0,true);
        left<-receiveMessage(id,priority,canBeLeader,ttl,pastLeaders,timestamp,0,false);
      } @ findLead(token)@currentContinuation;
      //return id;
    }
    return -1;
  }

}
