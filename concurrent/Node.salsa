module concurrent;

import java.io.*;
import java.util.*;

behavior Node{

  int id;                   //ID of the node
  int priority;             //priority of the node
  int tolerance;            //how long they can stand someone else being a leader
  int ttl;                  //
  int size;                 //number of all of the nodes

  String port;              //port of the node
  String host;              //host of the nodes

  boolean canBeLeader;      //if the node can be a leader
  boolean tempCanBeLeader;  //if there already is a leader
  boolean hasBeenLeader;    //if the node has been a leader
  boolean currentLeader;    //if the node is currently a leader
  boolean hasRevolted;      //if the node has revolted

  Node left;                //node to the left of the current node
  Node right;               //node to the right of the current node

  Node(String fileLine){                    //constructor
    String[] inputs = fileLine.split("\t"); //parses the line
    //inilizes all of the variables  
    id = Integer.parseInt(inputs[0]);       
    priority = Integer.parseInt(inputs[3]);
    tolerance = Integer.parseInt(inputs[4]);
    ttl = 1;
    size = 0;

    port = inputs[2];
    host = inputs[1];
    
    canBeLeader = true;
    tempCanBeLeader = true;
    hasBeenLeader = false;
    currentLeader = false;
    hasRevolted = false;
  }

  //Input: Node to the left of the current node
  //Output:None
  //Sets left node to the current node
  void setLeft(Node toLeft){
    left = toLeft;
    return;
  }
  //Input: Node to the right of the current node
  //Output:None
  //Sets right node to the current node
  void setRight(Node toRight){
    right=toRight;
    return;
  }
  //Input: size
  //Output:None
  //Sets the size
  void setSize(int s){
    size =s;
    return;
  }
  //Input: message to be printed
  //Output:mesage to the file
  //Opens the file and prints a status message to output.txt
  void printStatusMessage(String mess){
    //open file
    try{
     PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter("output.txt", true)));
      out.println(mess);//adds the message
      out.close();//closes the file
    }
    catch(IOException ioe){//error handing
      standardError<-println("[error] Can't open the file for writing.");
    }
  }

  //resets the hasRevolted once we are trying to find a new leader
  void reset(int counter){
    if (counter < size){
      hasRevolted = false;
      ttl = 1;
      counter++;
      left<-reset(counter);
    }
    return;
  }

  //once we have chosen a leader or trying to find a leader,
  //reset the tempCanBeLeader variable
  void leaderChosen(boolean chosen,int counter){
    if(counter < size){
      if(chosen == true){
        tempCanBeLeader = false;
      }else{
        tempCanBeLeader = true;
      }
      counter++;
      left<-leaderChosen(chosen,counter);
    }
    return;
  }

  //When a node v sees a message with w>v, it decides not to be a leader and becomes passive
  void receiveMessage(int senderId, int senderPriority, boolean senderLeaderStatus, int tTL, int pastLeaders,int time,int localTime){
    if( senderId == id && canBeLeader){ //if the current ID == the person we want to send to becomes leader
      currentLeader = true;             //current node is the new leader
      canBeLeader = false;
      printStatusMessage("ID=" + Integer.toString(senderId) + " became leader at t="+Integer.toString(time));
      time++;
      left<-leaderChosen(true,0)@ //makes sure nobody else can become a leader
      left<-reset(0)@             //resets all of the revolts
      left<-leaderTime(time,0,pastLeaders,0);   //pass timestamp messages
    }else{ //if we do no have a new leader
      tTL--;


      // printStatusMessage("check: "+senderId+" "+senderPriority+"|"+id+" "+priority+"\t"+tTL);
      


      if(priority > senderPriority && canBeLeader){ //
        senderLeaderStatus = false;
      }else if(priority == senderPriority && canBeLeader){//check based on ID
        if(id > senderId){
          senderLeaderStatus = false;
        }
      }

      if(tTL == 0){
        left<-replyMessage(id,senderId,senderLeaderStatus,pastLeaders,time,localTime);
        // right<-replyMessage(id,senderId,senderLeaderStatus,pastLeaders,time,localTime);
      }else if(tempCanBeLeader){
        left<-receiveMessage(senderId,senderPriority,senderLeaderStatus,tTL,pastLeaders,time,localTime);
        right<-receiveMessage(senderId,senderPriority,senderLeaderStatus,tTL,pastLeaders,time,localTime);
      }
    }

    return;
  }

//supoosed to send the current time to all the nodes, only passes to the left
void leaderTime(int time, int revolts,int pastLeaders, int localTime){
  if (localTime >= tolerance && currentLeader == false && hasRevolted==false){ //leader has been in power too long
    hasRevolted= true;  //sets the revolt flag
    revolts++;          //increases the number of revolts
    printStatusMessage("ID=" + Integer.toString(id) + " revolted at t="+Integer.toString(time));
    time++;
    localTime++;
    left<-leaderTime(time, revolts, pastLeaders,localTime);
  }else if (revolts >= ((size + 1)/2) && currentLeader){
    //time to elect a new leader
    currentLeader=false;
    pastLeaders++;
    time++;
    localTime++;
    printStatusMessage("ID=" + Integer.toString(id) + " was deposed at t="+Integer.toString(time-1));
    left<-leaderChosen(false,0)@
    left<-startElection(time,pastLeaders);
  }else{
    localTime++;
    time++;
    left<-leaderTime(time,revolts,pastLeaders,localTime);
  }
  return;
}


//need to decide when the original node is the leader
  void replyMessage(int newId, int senderId, boolean senderLeaderStatus, int pastLeaders,int time,int localTime){
    if(id == senderId){
      if(senderLeaderStatus){
        ttl *= 2;
        left<-receiveMessage(id,priority,canBeLeader,ttl,pastLeaders,time,localTime);
        right<-receiveMessage(id,priority,canBeLeader,ttl,pastLeaders,time,localTime);
      }else{
        left<-startElection(time,pastLeaders); //go on to the next person
      }
    }else{
      left<-replyMessage(newId,senderId,senderLeaderStatus,pastLeaders,time,localTime);
      // right<-replyMessage(newId,senderId,senderLeaderStatus,pastLeaders,time,localTime);
    }
    return;
  }

  //This is to kick off finding a new leader
  void startElection(int timestamp, int pastLeaders){
    if(pastLeaders == size){
      printStatusMessage("End of simulation");
      return;
    }
    if(hasBeenLeader){//checks if they have been a leader
      left<-startElection(timestamp,pastLeaders); //go on to the next person
    }else if(tempCanBeLeader){
      left<-receiveMessage(id,priority,canBeLeader,ttl,pastLeaders,timestamp,0);
      right<-receiveMessage(id,priority,canBeLeader,ttl,pastLeaders,timestamp,0);
    }
    return;
  }


}